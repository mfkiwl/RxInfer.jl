<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Nonlinear Sensor Fusion · RxInfer.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://biaslab.github.io/RxInfer.jl/examples/Nonlinear Sensor Fusion/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/theme.css" rel="stylesheet" type="text/css"/><link href="../../assets/header.css" rel="stylesheet" type="text/css"/><script src="../../assets/header.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.svg" alt="RxInfer.jl logo"/><img class="docs-dark-only" src="../../assets/logo-dark.svg" alt="RxInfer.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">RxInfer.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">User guide</span><ul><li><a class="tocitem" href="../../manuals/getting-started/">Getting started</a></li><li><a class="tocitem" href="../../manuals/model-specification/">Model specification</a></li><li><a class="tocitem" href="../../manuals/constraints-specification/">Constraints specification</a></li><li><a class="tocitem" href="../../manuals/meta-specification/">Meta specification</a></li><li><input class="collapse-toggle" id="menuitem-2-5" type="checkbox"/><label class="tocitem" for="menuitem-2-5"><span class="docs-label">Inference specification</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../manuals/inference/overview/">Overview</a></li><li><a class="tocitem" href="../../manuals/inference/inference/">Static dataset</a></li><li><a class="tocitem" href="../../manuals/inference/rxinference/">Real-time dataset / reactive inference</a></li><li><a class="tocitem" href="../../manuals/inference/manual/">Manual inference specification</a></li></ul></li></ul></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="../../library/functional-forms/">Built-in functional form constraints</a></li><li><a class="tocitem" href="../../library/model-specification/">Model specification</a></li><li><a class="tocitem" href="../../library/bethe-free-energy/">Bethe Free Energy</a></li><li><a class="tocitem" href="../../library/exported-methods/">Exported methods</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../Overview/">Overview</a></li><li><a class="tocitem" href="../Advanced Tutorial/">Advanced Tutorial</a></li><li><a class="tocitem" href="../Assessing People Skills/">Assessing People Skills</a></li><li><a class="tocitem" href="../Autoregressive Model/">Autoregressive Model</a></li><li><a class="tocitem" href="../Coin Toss Model/">Coin Toss Model</a></li><li><a class="tocitem" href="../Conjugate-NonConjugate Variational Message Passing/">Conjugate-NonConjugate Variational Message Passing</a></li><li><a class="tocitem" href="../Custom nonlinear node/">Custom nonlinear node</a></li><li><a class="tocitem" href="../GPRegression by SSM/">GPRegression by SSM</a></li><li><a class="tocitem" href="../Gamma Mixture/">Gamma Mixture</a></li><li><a class="tocitem" href="../Gaussian Linear Dynamical System/">Gaussian Linear Dynamical System</a></li><li><a class="tocitem" href="../Gaussian Mixture Univariate/">Gaussian Mixture Univariate</a></li><li><a class="tocitem" href="../Gaussian Mixtures Multivariate/">Gaussian Mixtures Multivariate</a></li><li><a class="tocitem" href="../Global Parameter Optimisation/">Global Parameter Optimisation</a></li><li><a class="tocitem" href="../Handling Missing Data/">Handling Missing Data</a></li><li><a class="tocitem" href="../Hidden Markov Model/">Hidden Markov Model</a></li><li><a class="tocitem" href="../Hierarchical Gaussian Filter/">Hierarchical Gaussian Filter</a></li><li><a class="tocitem" href="../Identification Problem/">Identification Problem</a></li><li><a class="tocitem" href="../Infinite Data Stream/">Infinite Data Stream</a></li><li><a class="tocitem" href="../Invertible Neural Network Tutorial/">Invertible Neural Network Tutorial</a></li><li><a class="tocitem" href="../Kalman filter with LSTM network driven dynamic/">Kalman filter with LSTM network driven dynamic</a></li><li><a class="tocitem" href="../Linear Regression/">Linear Regression</a></li><li><a class="tocitem" href="../Nonlinear Noisy Pendulum/">Nonlinear Noisy Pendulum</a></li><li><a class="tocitem" href="../Nonlinear Rabbit Population/">Nonlinear Rabbit Population</a></li><li class="is-active"><a class="tocitem" href>Nonlinear Sensor Fusion</a></li><li><a class="tocitem" href="../Nonlinear Virus Spread/">Nonlinear Virus Spread</a></li><li><a class="tocitem" href="../Probit Model (EP)/">Probit Model (EP)</a></li><li><a class="tocitem" href="../RTS vs BIFM Smoothing/">RTS vs BIFM Smoothing</a></li></ul></li><li><span class="tocitem">Contributing</span><ul><li><a class="tocitem" href="../../contributing/overview/">Overview</a></li><li><a class="tocitem" href="../../contributing/new-example/">Adding a new example</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>Nonlinear Sensor Fusion</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Nonlinear Sensor Fusion</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/biaslab/RxInfer.jl/blob/main/docs/src/examples/Nonlinear Sensor Fusion.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><p>This example has been auto-generated from the <a href="https://github.com/biaslab/RxInfer.jl/tree/main/examples"><code>examples/</code></a> folder at GitHub repository.</p><h1 id="examples-nonlinear-sensor-fusion"><a class="docs-heading-anchor" href="#examples-nonlinear-sensor-fusion">Nonlinear Sensor Fusion</a><a id="examples-nonlinear-sensor-fusion-1"></a><a class="docs-heading-anchor-permalink" href="#examples-nonlinear-sensor-fusion" title="Permalink"></a></h1><pre><code class="language-julia hljs"># Activate local environment, see `Project.toml`
import Pkg; Pkg.activate(&quot;.&quot;); Pkg.instantiate(); 
using RxInfer, Random, LinearAlgebra, Distributions, Plots, StatsPlots, Flux, DataFrames, DelimitedFiles, StableRNGs</code></pre><p>In a secret ongoing mission to Mars, NASA has deployed its custom lunar roving vehicle, called WALL-E, to explore the area and to discover hidden minerals. During one of the solar storm, WALL-E&#39;s GPS unit got damaged, preventing it from accurately locating itself. The engineers at NASA were devastated as they developed the project over the past couple of years and spend most of their funding on it. Without being able to locate WALL-E, they were unable to complete their mission.</p><p>A smart group of engineers came up with a solution to locate WALL-E. They decided to repurpose 3 nearby satelites as beacons for WALL-E, allowing it to detect its relative location to these beacons. However, these satelites were old and therefore WALL-E was only able to obtain noisy estimates of its distance to these beacons. These distances were communicated back to earth, where the engineers tried to figure our WALL-E&#39;s location. Luckily they knew the locations of these satelites and together with the noisy estimates of the distance to WALL-E they can infer the exact location of the moving WALL-E.</p><p>To illustrate these noisy measurements, the engineers decided to plot them:</p><pre><code class="language-julia hljs"># fetch measurements
beacon_locations = readdlm(&quot;data/sensor_fusion/beacons.txt&quot;)
distances = readdlm(&quot;data/sensor_fusion/distances.txt&quot;)
position = readdlm(&quot;data/sensor_fusion/position.txt&quot;)
nr_observations = size(distances, 1);</code></pre><pre><code class="language-julia hljs"># plot beacon and actual location of WALL-E
p1 = scatter(beacon_locations[:,1], beacon_locations[:,2], markershape=:utriangle, markersize=10, legend=:topleft, label=&quot;beacon locations&quot;)
plot!(position[1,:], position[2,:], label=&quot;actual location&quot;, linewidth=3, linestyle=:dash, arrow=(:closed, 2.0), aspect_ratio=1.0)
xlabel!(&quot;longitude [m]&quot;), ylabel!(&quot;latitude [m]&quot;)

# plot noisy distance measurements
p2 = plot(distances, legend=:topleft, linewidth=3, label=[&quot;distance to beacon 1&quot; &quot;distance to beacon 2&quot; &quot;distance to beacon 3&quot;])
xlabel!(&quot;time [sec]&quot;), ylabel!(&quot;distance [m]&quot;)

plot(p1, p2, size=(1200, 500))</code></pre><p><img src="../../assets/examples/Nonlinear Sensor Fusion_3_1.png" alt/></p><p>In order to track the location of WALL-E based on the noisy distance measurements to the beacon, the engineers developed a probabilistic model for the movements for WALL-E and the distance measurements that followed from this. The engineers assumed that the position of WALL-E at time <span>$t$</span>, denoted by <span>$z_t$</span>, follows a 2-dimensional normal random walk:</p><p class="math-container">\[\begin{aligned}
 &amp; p(z_t \mid z_{t - 1}) = \mathcal{N}(z_t \mid z_{t-1},~\mathrm{I}_{2}),\\
\end{aligned}\]</p><p>where <span>$\mathrm{I}_2$</span> denotes the 2-dimensional identity matrix. From the current position of WALL-E, we specify our noisy distance measurements <span>$y_t$</span> as a noisy set of the distances between WALL-E and the beacons, specified by <span>$s_i$</span>:</p><p class="math-container">\[\begin{aligned}
 &amp; p(y_t \mid z_t)  = \mathcal{N} \left (y_t \left \vert \begin{bmatrix} \| z_{t} - s_{1}\| \\ \|z_{t} - s_{2}\| \\ \|z_{t} - s_{3}\|\end{bmatrix}\!,~\mathrm{I}_{3}\! \right . \right)\!.
\end{aligned}\]</p><p>The engineers are smart enough to automate the probabilistic inference procedure using <code>RxInfer.jl</code>. They specify the probabilistic model as:</p><pre><code class="language-julia hljs"># function to compute distance to beacons
function compute_distances(z)    
    distance1 = norm(z - beacon_locations[1,:])
    distance2 = norm(z - beacon_locations[2,:])
    distance3 = norm(z - beacon_locations[3,:])
    distances = [distance1, distance2, distance3]
end;</code></pre><pre><code class="language-julia hljs">@model function random_walk_model(nr_observations)
    
    # specify covariance matrices
    W = diageye(2)
    R = diageye(3)

    # allocate locations and observations
    z = randomvar(nr_observations)
    y = datavar(Vector{Float64}, nr_observations)

    # specify initial estimates of the location
    z[1] ~ MvNormalMeanCovariance(zeros(2), diageye(2)) 
    y[1] ~ MvNormalMeanCovariance(compute_distances(z[1]), diageye(3))

    # loop over time steps
    for t in 2:nr_observations

        # specify random walk state transition model
        z[t] ~ MvNormalMeanPrecision(z[t-1], W)

        # specify non-linear distance observations model
        y[t] ~ MvNormalMeanPrecision(compute_distances(z[t]), R)
        
    end

end;</code></pre><p>Because of the non-linearity, exact probabilistic inference is intractable. Therefore we resort to Conjugate-NonConjugate Variational Inference (CVI) following the paper <a href="https://reader.elsevier.com/reader/sd/pii/S0888613X22000950?token=EFB22E01793BD0BF73EECC9702C315644969403BD44B13FA850E9F66C8A49E88C0D5C68A9AD03301C609DA443DB33F80&amp;originRegion=eu-west-1&amp;originCreation=20221027115856">Probabilistic programming with stochastic variational message passing</a>. This requires setting the <code>@meta</code> macro in <code>RxInfer.jl</code>.</p><pre><code class="language-julia hljs">@meta function random_walk_model_meta(nr_samples, nr_iterations, rng)
    compute_distances(z) -&gt; CVIApproximation(rng, nr_samples, nr_iterations, Descent(0.1))
end;</code></pre><p>Because the engineers are using <code>RxInfer.jl</code>, they can automate the inference procedure. They run the model once with a limited numbers of samples and iterations, for speed, and once for accuracy.</p><pre><code class="language-julia hljs">results_fast = inference(
    model = random_walk_model(nr_observations),
    meta = random_walk_model_meta(1, 3, StableRNG(42)),
    data = (y = [distances[t,:] for t in 1:nr_observations],),
    iterations = 100,
    free_energy = false,
    returnvars = (z = KeepLast(),),
    initmessages = (z = MvNormalMeanPrecision(zeros(2), 0.01 * diageye(2)),),
);</code></pre><pre><code class="language-julia hljs">results_accuracy = inference(
    model = random_walk_model(nr_observations),
    meta = random_walk_model_meta(1000, 100, StableRNG(42)),
    data = (y = [distances[t,:] for t in 1:nr_observations],),
    iterations = 100,
    free_energy = false,
    returnvars = (z = KeepLast(),),
    initmessages = (z = MvNormalMeanPrecision(zeros(2), 0.01 * diageye(2)),),
);</code></pre><p>After running this fast inference procedure, the engineers plot the results and evaluate the performance:</p><pre><code class="language-julia hljs"># plot beacon and actual and estimated location of WALL-E (fast inference)
p1 = scatter(beacon_locations[:,1], beacon_locations[:,2], markershape=:utriangle, markersize=10, legend=:topleft, label=&quot;beacon locations&quot;)
plot!(position[1,:], position[2,:], label=&quot;actual location&quot;, linewidth=3, linestyle=:dash, arrow=(:closed, 2.0), aspect_ratio=1.0)
map(posterior -&gt; covellipse!(mean(posterior), cov(posterior), color=&quot;red&quot;, label=&quot;&quot;, n_std=2), results_fast.posteriors[:z])
xlabel!(&quot;longitude [m]&quot;), ylabel!(&quot;latitude [m]&quot;), title!(&quot;Fast (1 sample, 3 iterations)&quot;); p1.series_list[end][:label] = &quot;estimated location ±2σ&quot;

# plot beacon and actual and estimated location of WALL-E (accurate inference)
p2 = scatter(beacon_locations[:,1], beacon_locations[:,2], markershape=:utriangle, markersize=10, legend=:topleft, label=&quot;beacon locations&quot;)
plot!(position[1,:], position[2,:], label=&quot;actual location&quot;, linewidth=3, linestyle=:dash, arrow=(:closed, 2.0), aspect_ratio=1.0)
map(posterior -&gt; covellipse!(mean(posterior), cov(posterior), color=&quot;red&quot;, label=&quot;&quot;, n_std=2), results_accuracy.posteriors[:z])
xlabel!(&quot;longitude [m]&quot;), ylabel!(&quot;latitude [m]&quot;), title!(&quot;Accurate (1000 samples, 100 iterations)&quot;); p2.series_list[end][:label] = &quot;estimated location ±2σ&quot;

plot(p1, p2, size=(1200, 500))</code></pre><p><img src="../../assets/examples/Nonlinear Sensor Fusion_9_1.png" alt/></p><p>The engineers were very happy with the solution, as it meant that the Mars mission could continue. However, they noted that the estimates began to deviate after WALL-E moved further away from the beacons. They deemed this was likely due to the noise in the distance measurements. Therefore, the engineers decided to adapt the model, such that they would also infer the process and observation noise precision matrices, <span>$Q$</span> and <span>$R$</span> respectively. They did this by adding Wishart priors to those matrices:</p><p class="math-container">\[\begin{aligned}
 &amp; p(Q) = \mathcal{W}(Q \mid 3, \mathrm{I}_2), \\
 &amp; p(R) = \mathcal{W}(R \mid 4, \mathrm{I}_3), \\
 &amp; p(z_t \mid z_{t - 1}, Q) = \mathcal{N}(z_t \mid z_{t-1}, Q^{-1}),\\
 &amp; p(y_t \mid z_t, R)  = \mathcal{N} \left (y_t \left \vert \begin{bmatrix} \| z_{t} - s_{1}\| \\ \|z_{t} - s_{2}\| \\ \|z_{t} - s_{3}\|\end{bmatrix}\!,~R^{-1}\! \right . \right)\!.
\end{aligned}\]</p><pre><code class="language-julia hljs">@model function random_walk_model_wishart(nr_observations)

    # allocate locations and observations
    z = randomvar(nr_observations)
    y = datavar(Vector{Float64}, nr_observations)

    # set priors on precision matrices
    Q ~ Wishart(3, diageye(2))
    R ~ Wishart(4, diageye(3))

    # specify initial estimates of the location
    z[1] ~ MvNormalMeanCovariance(zeros(2), diageye(2)) 
    y[1] ~ MvNormalMeanCovariance(compute_distances(z[1]), diageye(3))

    # loop over time steps
    for t in 2:nr_observations

        # specify random walk state transition model
        z[t] ~ MvNormalMeanPrecision(z[t-1], Q)

        # specify non-linear distance observations model
        y[t] ~ MvNormalMeanPrecision(compute_distances(z[t]), R)
        
    end

end;</code></pre><pre><code class="language-julia hljs">meta = @meta begin 
    compute_distances(z) -&gt; CVIApproximation(StableRNG(42), 2000, 100, Descent(0.01))
end;</code></pre><p>Because of the added complexity with the Wishart distributions, the engineers simplify the problem by employing a structured mean-field factorization:</p><pre><code class="language-julia hljs">constraints = @constraints begin
    q(z, Q, R) = q(z)q(Q)q(R)
end;</code></pre><p>The engineers run the inference procedure again and decide to track the inference performance using the Bethe free energy.</p><pre><code class="language-julia hljs">results_wishart = inference(
    model = random_walk_model_wishart(nr_observations),
    data = (y = [distances[t,:] for t in 1:nr_observations],),
    iterations = 100,
    free_energy = true,
    returnvars = (z = KeepLast(),),
    constraints = constraints,
    meta = meta,
    initmessages = (z = MvNormalMeanPrecision(zeros(2), 0.01 * diageye(2)),),
    initmarginals = (R = Wishart(4, diageye(3)), Q = Wishart(3, diageye(2)))
);</code></pre><p>They plot the new estimates and the performance over time, and luckily WALL-E is found!</p><pre><code class="language-julia hljs"># plot beacon and actual and estimated location of WALL-E (fast inference)
p1 = scatter(beacon_locations[:,1], beacon_locations[:,2], markershape=:utriangle, markersize=10, legend=:topleft, label=&quot;beacon locations&quot;)
plot!(position[1,:], position[2,:], label=&quot;actual location&quot;, linewidth=3, linestyle=:dash, arrow=(:closed, 2.0), aspect_ratio=1.0)
map(posterior -&gt; covellipse!(mean(posterior), cov(posterior), color=&quot;red&quot;, label=&quot;&quot;, n_std=2), results_wishart.posteriors[:z])
xlabel!(&quot;longitude [m]&quot;), ylabel!(&quot;latitude [m]&quot;); p1.series_list[end][:label] = &quot;estimated location ±2σ&quot;

# plot bethe free energy performance
p2 = plot(results_wishart.free_energy, label = &quot;&quot;)
xlabel!(&quot;iteration&quot;), ylabel!(&quot;Bethe free energy [nats]&quot;)

plot(p1, p2, size=(1200, 500))</code></pre><p><img src="../../assets/examples/Nonlinear Sensor Fusion_14_1.png" alt/></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../Nonlinear Rabbit Population/">« Nonlinear Rabbit Population</a><a class="docs-footer-nextpage" href="../Nonlinear Virus Spread/">Nonlinear Virus Spread »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Thursday 3 November 2022 15:16">Thursday 3 November 2022</span>. Using Julia version 1.8.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
